<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <canvas id="particle-canvas"></canvas>
    <h1 id="header-title"><span class="draggable-word">Shrey</span> <span class="draggable-word">Patel's</span> <span class="draggable-word">Portfolio</span></h1>
    <p>Welcome to my interactive portfolio, try changing the website theme and layout. I have a collection of my work and projects here as well.</p>
    
    <div class="nav-buttons">
        <a href="#" id="projects-btn">Projects</a>
        <a href="Shrey_Patel_CV_Corporate.docx" download="Shrey_Patel_CV.pdf">CV</a>
        <a href="#" id="contact-btn">Contact</a>
    </div>

    <h2 id="projects-title" style="display: none;">GitHub Projects</h2>
    <div class="projects-wrapper" id="projects-wrapper" style="display: none;">
        <button class="scroll-btn scroll-left" id="scroll-left">‹</button>
        <div id="projects-container" class="projects-container">
            <div class="loading">Loading projects...</div>
        </div>
        <button class="scroll-btn scroll-right" id="scroll-right">›</button>
    </div>

    <!-- Contact Overlay -->
    <div id="contact-overlay" class="contact-overlay" aria-hidden="true"></div>

    <!-- Contact Panel -->
    <div id="contact-panel" class="contact-panel" aria-hidden="true">
        <button id="close-contact" class="close-btn" aria-label="Close contact panel">×</button>
        <div class="contact-inner">
            <h3>Contact</h3>
            <p>Email: <a href="mailto:patelshrey16@gmail.com">patelshrey16@gmail.com</a></p>
            <p>LinkedIn: <a href="https://www.linkedin.com/in/shrey-patel6/" target="_blank" rel="noopener">linkedin.com/in/shrey-patel6</a></p>
            <form id="contact-form" action="https://formsubmit.co/ajax/patelshrey16@gmail.com" method="POST">
                <div class="control-group">
                    <label for="contact-name">Name</label>
                    <input type="text" id="contact-name" name="name" placeholder="Your name" required>
                </div>
                <div class="control-group">
                    <label for="contact-email">Email</label>
                    <input type="email" id="contact-email" name="email" placeholder="your@email.com" required>
                </div>
                <div class="control-group">
                    <label for="contact-message">Message</label>
                    <textarea id="contact-message" name="message" rows="4" placeholder="Hi..." required></textarea>
                </div>
                <div class="control-group">
                    <button type="submit" class="reset-btn">Send</button>
                </div>
                <input type="hidden" name="_captcha" value="false">
            </form>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel" id="control-panel">
        <div class="panel-content" id="panel-content">
            <h3>Website Controls</h3>
            
            <div class="control-section-row">
                <div class="control-section">
                    <h4>Colors</h4>
                    <div class="control-group">
                        <label for="accent-color">Accent Color:</label>
                        <input type="color" id="accent-color" value="#58a6ff">
                    </div>
                    <div class="control-group">
                        <label for="bg-color">Background Dark:</label>
                        <input type="color" id="bg-color" value="#0d1117">
                    </div>
                </div>

                <div class="control-section">
                    <h4>Particles</h4>
                    <div class="control-group">
                        <label for="particle-count">Particle Count: <span id="particle-count-value">50</span></label>
                        <input type="range" id="particle-count" min="10" max="200" value="50">
                    </div>
                    <div class="control-group">
                        <label for="particle-speed">Particle Speed: <span id="particle-speed-value">0.5</span></label>
                        <input type="range" id="particle-speed" min="0.1" max="2" step="0.1" value="0.5">
                    </div>
                    <div class="control-group">
                        <label for="glow-intensity">Glow Intensity: <span id="glow-intensity-value">0.1</span></label>
                        <input type="range" id="glow-intensity" min="0" max="0.5" step="0.05" value="0.1">
                    </div>
                </div>

                <div class="control-section">
                    <h4>Effects</h4>
                    <div class="control-group">
                        <label for="border-radius">Border Radius: <span id="border-radius-value">0.75rem</span></label>
                        <input type="range" id="border-radius" min="0" max="1" step="0.1" value="0.75">
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="enable-mouse-trails" checked>
                            Mouse Trails
                        </label>
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="enable-draggable" checked>
                            Draggable Title
                        </label>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <button id="reset-controls" class="reset-btn">Reset to Default</button>
            </div>
        </div>
    </div>

    <script>
        async function fetchGitHubProjects() {
            try {
                const response = await fetch('https://api.github.com/users/ShreyPatel383/repos?sort=stars&per_page=6');
                const response2 = await fetch('https://api.github.com/users/thunder383/repos?sort=stars&per_page=6');
                const repos = await response.json();
                const repos2 = await response2.json();
                const container = document.getElementById('projects-container');
                
                // Combine repos from both accounts
                const allRepos = [...repos, ...repos2].sort((a, b) => b.stargazers_count - a.stargazers_count);
                
                if (allRepos.length === 0) {
                    container.innerHTML = '<p>No projects found.</p>';
                    return;
                }

                container.innerHTML = allRepos.map(repo => `
                    <div class="project-card">
                        <h3>${repo.name}</h3>
                        <p class="project-description">${repo.description || 'No description'}</p>
                        <div class="project-meta">
                            ${repo.language ? `<span class="project-language">${repo.language}</span>` : ''}
                            ${repo.stargazers_count > 0 ? `<span class="project-stars">⭐ ${repo.stargazers_count}</span>` : ''}
                        </div>
                        <a href="${repo.html_url}" target="_blank" class="project-link">View on GitHub →</a>
                    </div>
                `).join('');
                
                // Animate cards if section is already visible
                if (document.getElementById('projects-wrapper').style.display !== 'none') {
                    animateCards();
                }
            } catch (error) {
                console.error('Error fetching projects:', error);
                document.getElementById('projects-container').innerHTML = '<p>Error loading projects.</p>';
            }
        }

        function animateCards() {
            const cards = document.querySelectorAll('.project-card');
            cards.forEach(card => {
                card.classList.add('animate');
            });
        }

        fetchGitHubProjects();

        // Projects button toggle
        const projectsBtn = document.getElementById('projects-btn');
        const projectsWrapper = document.getElementById('projects-wrapper');
        const projectsTitle = document.getElementById('projects-title');

        projectsBtn.addEventListener('click', (e) => {
            e.preventDefault();
            const isHidden = projectsWrapper.style.display === 'none';
            
            if (isHidden) {
                // Show elements
                projectsWrapper.style.display = 'flex';
                projectsTitle.style.display = 'block';
                
                // Trigger animation
                setTimeout(() => {
                    projectsTitle.classList.add('slide-down');
                    projectsWrapper.classList.add('slide-in');
                    animateCards();
                }, 10);
            } else {
                // Hide elements and remove animation classes
                projectsWrapper.classList.remove('slide-in');
                projectsTitle.classList.remove('slide-down');
                
                const cards = document.querySelectorAll('.project-card');
                cards.forEach(card => {
                    card.classList.remove('animate');
                });
                
                setTimeout(() => {
                    projectsWrapper.style.display = 'none';
                    projectsTitle.style.display = 'none';
                }, 300);
            }
        });
        const scrollLeft = document.getElementById('scroll-left');
        const scrollRight = document.getElementById('scroll-right');
        const projectsContainer = document.getElementById('projects-container');

        scrollLeft.addEventListener('click', () => {
            projectsContainer.scrollBy({
                left: -320,
                behavior: 'smooth'
            });
        });

        scrollRight.addEventListener('click', () => {
            projectsContainer.scrollBy({
                left: 320,
                behavior: 'smooth'
            });
        });

        // Make header words draggable with physics
        const draggableWords = document.querySelectorAll('.draggable-word');
        const wordPhysics = new Map();
        let draggedElement = null;
        let offsetX = 0;
        let offsetY = 0;
        let startX = 0;
        let startY = 0;
        let lastX = 0;
        let lastY = 0;
        let lastTime = 0;

        draggableWords.forEach(word => {
            wordPhysics.set(word, {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                rotation: 0,
                angularVelocity: 0
            });

            word.addEventListener('mousedown', (e) => {
                draggedElement = word;
                startX = e.clientX;
                startY = e.clientY;
                lastX = e.clientX;
                lastY = e.clientY;
                lastTime = Date.now();
                const physics = wordPhysics.get(word);
                offsetX = physics.x;
                offsetY = physics.y;
                physics.vx = 0;
                physics.vy = 0;
                physics.angularVelocity = 0;
            });
        });

        document.addEventListener('mousemove', (e) => {
            if (draggedElement) {
                const currentTime = Date.now();
                const deltaTime = Math.max(1, currentTime - lastTime) / 16; // normalize to 16ms frame
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                const newX = offsetX + deltaX;
                const newY = offsetY + deltaY;
                
                // Calculate velocity with clamping to prevent exaggerated movement
                let velocityX = (e.clientX - lastX) / deltaTime;
                let velocityY = (e.clientY - lastY) / deltaTime;
                
                // Clamp velocity to reasonable values
                const maxVelocity = 15;
                velocityX = Math.max(-maxVelocity, Math.min(maxVelocity, velocityX));
                velocityY = Math.max(-maxVelocity, Math.min(maxVelocity, velocityY));
                
                const physics = wordPhysics.get(draggedElement);
                physics.x = newX;
                physics.y = newY;
                physics.vx = velocityX * 0.3;
                physics.vy = velocityY * 0.3;
                physics.angularVelocity = velocityX * 0.05;
                physics.rotation = velocityX * 1;
                
                updateWordTransform(draggedElement);
                
                lastX = e.clientX;
                lastY = e.clientY;
                lastTime = currentTime;
            }
        });

        function updateWordTransform(word) {
            const physics = wordPhysics.get(word);
            word.style.transform = `translate(${physics.x}px, ${physics.y}px) rotate(${physics.rotation}deg)`;
        }

        document.addEventListener('mouseup', () => {
            if (draggedElement) {
                // Small momentum boost on release
                const physics = wordPhysics.get(draggedElement);
                physics.vx *= 1.1;
                physics.vy *= 1.1;
                draggedElement = null;
            }
        });

        // Physics animation loop
        function animateWords() {
            let anyMoving = false;
            
            draggableWords.forEach(word => {
                if (word === draggedElement) return; // Skip currently dragged word
                
                const physics = wordPhysics.get(word);
                const speed = Math.sqrt(physics.vx ** 2 + physics.vy ** 2);
                
                if (speed > 0.05 || Math.abs(physics.angularVelocity) > 0.05) {
                    anyMoving = true;
                    
                    // Apply momentum
                    physics.x += physics.vx;
                    physics.y += physics.vy;
                    physics.rotation += physics.angularVelocity;
                    
                    // Apply damping (friction) - increased for controlled motion
                    physics.vx *= 0.94;
                    physics.vy *= 0.94;
                    physics.angularVelocity *= 0.90;
                    
                    updateWordTransform(word);
                }
            });
            
            // Always keep looping while dragging or moving
            requestAnimationFrame(animateWords);
        }

        animateWords();

        // Particle system for background
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles = [];
        const particleCount = 50;
        const connectionDistance = 150;
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        
        // Global settings for controls
        window.glowIntensity = 0.1;
        window.enableMouseTrails = true;

        // Track mouse position
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.radius = Math.random() * 2 + 1;
                this.opacity = Math.random() * 0.5 + 0.3;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > canvas.height) this.vy *= -1;

                this.x = Math.max(0, Math.min(canvas.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height, this.y));
            }

            draw() {
                // Glow effect
                const glowIntensity = window.glowIntensity || 0.1;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 6);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${this.opacity * glowIntensity})`);
                gradient.addColorStop(0.6, `rgba(150, 100, 255, ${this.opacity * glowIntensity * 0.5})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x - this.radius * 6, this.y - this.radius * 6, this.radius * 12, this.radius * 12);

                // Core dot
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity * 0.7})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function initParticles() {
            particles.length = 0;
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function drawConnections() {
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < connectionDistance) {
                        const opacity = (1 - distance / connectionDistance) * 0.3;
                        ctx.strokeStyle = `rgba(200, 100, 255, ${opacity})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }

                // Draw connection to mouse
                if (window.enableMouseTrails) {
                    const dxMouse = particles[i].x - mouseX;
                    const dyMouse = particles[i].y - mouseY;
                    const distanceToMouse = Math.sqrt(dxMouse * dxMouse + dyMouse * dyMouse);

                    if (distanceToMouse < connectionDistance) {
                        const opacity = (1 - distanceToMouse / connectionDistance) * 0.2;
                        ctx.strokeStyle = `rgba(200, 100, 255, ${opacity})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(mouseX, mouseY);
                        ctx.stroke();
                    }
                }
            }
        }

        function drawMouseGlow() {
            if (!window.enableMouseTrails) return; // Skip if disabled
            
            const gradient = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, 200);
            gradient.addColorStop(0, 'rgba(150, 100, 255, 0.05)');
            gradient.addColorStop(0.5, 'rgba(150, 100, 255, 0.005)');
            gradient.addColorStop(1, 'rgba(150, 100, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(mouseX - 200, mouseY - 200, 400, 400);
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set blend mode to make lights additive
            ctx.globalCompositeOperation = 'lighten';

            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            drawConnections();
            drawMouseGlow();
            
            ctx.globalCompositeOperation = 'source-over';
            requestAnimationFrame(animate);
        }

        initParticles();
        animate();

        // Control Panel
        const accentColorInput = document.getElementById('accent-color');
        const bgColorInput = document.getElementById('bg-color');
        const particleCountInput = document.getElementById('particle-count');
        const particleSpeedInput = document.getElementById('particle-speed');
        const glowIntensityInput = document.getElementById('glow-intensity');
        const borderRadiusInput = document.getElementById('border-radius');
        const enableMouseTrailsInput = document.getElementById('enable-mouse-trails');
        const enableDraggableInput = document.getElementById('enable-draggable');
        const resetBtn = document.getElementById('reset-controls');

        // Accent color change
        accentColorInput.addEventListener('change', (e) => {
            const color = e.target.value;
            document.documentElement.style.setProperty('--accent', color);
        });

        // Background color change
        bgColorInput.addEventListener('change', (e) => {
            const color = e.target.value;
            document.documentElement.style.setProperty('--bg-primary', color);
        });

        // Particle count change
        particleCountInput.addEventListener('input', (e) => {
            const newCount = parseInt(e.target.value);
            document.getElementById('particle-count-value').textContent = newCount;
            // Remove excess particles if count decreased
            while (particles.length > newCount) {
                particles.pop();
                wordPhysics.delete(particles[particles.length]);
            }
            // Add new particles if count increased
            while (particles.length < newCount) {
                particles.push(new Particle());
            }
        });

        // Particle speed change
        particleSpeedInput.addEventListener('input', (e) => {
            const multiplier = e.target.value;
            document.getElementById('particle-speed-value').textContent = multiplier;
            particles.forEach(p => {
                p.vx = (Math.random() - 0.5) * parseFloat(multiplier);
                p.vy = (Math.random() - 0.5) * parseFloat(multiplier);
            });
        });

        // Glow intensity change
        glowIntensityInput.addEventListener('input', (e) => {
            const intensity = e.target.value;
            document.getElementById('glow-intensity-value').textContent = intensity;
            // Store for use in particle draw
            window.glowIntensity = parseFloat(intensity);
        });

        // Border radius change
        borderRadiusInput.addEventListener('input', (e) => {
            const radius = e.target.value + 'rem';
            document.getElementById('border-radius-value').textContent = radius;
            document.documentElement.style.setProperty('--border-radius', radius);
            // Update all elements with border-radius
            document.querySelectorAll('a, button, .project-card, .scroll-btn, .panel-toggle, .panel-content').forEach(el => {
                el.style.borderRadius = radius;
            });
        });

        // Toggle mouse trails
        enableMouseTrailsInput.addEventListener('change', (e) => {
            window.enableMouseTrails = e.target.checked;
        });

        // Toggle draggable title
        enableDraggableInput.addEventListener('change', (e) => {
            draggableWords.forEach(word => {
                word.style.pointerEvents = e.target.checked ? 'auto' : 'none';
                word.style.opacity = e.target.checked ? '1' : '0.5';
            });
        });

        // Reset to default
        resetBtn.addEventListener('click', () => {
            accentColorInput.value = '#58a6ff';
            bgColorInput.value = '#0d1117';
            particleCountInput.value = '50';
            particleSpeedInput.value = '0.5';
            glowIntensityInput.value = '0.1';
            borderRadiusInput.value = '0.75';
            enableMouseTrailsInput.checked = true;
            enableDraggableInput.checked = true;

            // Apply defaults
            document.documentElement.style.setProperty('--accent', '#58a6ff');
            document.documentElement.style.setProperty('--bg-primary', '#0d1117');
            document.getElementById('particle-count-value').textContent = '50';
            document.getElementById('particle-speed-value').textContent = '0.5';
            document.getElementById('glow-intensity-value').textContent = '0.1';
            document.getElementById('border-radius-value').textContent = '0.75rem';
            window.glowIntensity = 0.1;
            window.enableMouseTrails = true;

            // Reinitialize particles
            const oldCount = particles.length;
            particles.length = 0;
            initParticles();

            // Update border radius
            document.querySelectorAll('a, button, .project-card, .scroll-btn, .panel-toggle, .panel-content').forEach(el => {
                el.style.borderRadius = '0.75rem';
            });
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>

    <script>
        // Handle contact form submission with FormSubmit.co
        (function() {
            function setupContactForm() {
                const form = document.getElementById('contact-form');
                if (!form) return;
                
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    
                    const formData = new FormData(form);
                    
                    console.log('Submitting form with data:', Object.fromEntries(formData));
                    
                    fetch(form.action, {
                        method: 'POST',
                        body: formData
                    }).then(response => {
                        console.log('Form submitted successfully', response.status);
                        if (response.ok) {
                            alert('Message sent successfully!');
                            form.reset();
                            // Close panel if it exists
                            const closePanel = window.__closeContactPanel;
                            if (closePanel) closePanel();
                        } else {
                            alert('There was an error sending your message. Please try again.');
                        }
                    }).catch(error => {
                        console.error('Form submission error:', error);
                        alert('Error sending message: ' + error.message);
                    });
                });
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', setupContactForm);
            } else {
                setupContactForm();
            }
        })();
    </script>

    <script>
        (function(){
            const contactBtn = document.getElementById('contact-btn');
            const contactPanel = document.getElementById('contact-panel');
            const overlay = document.getElementById('contact-overlay');
            const closeBtn = document.getElementById('close-contact');

            function openPanel() {
                if (!contactPanel || !contactBtn) return;
                const rect = contactBtn.getBoundingClientRect();
                const gap = 30;
                const desiredWidth = 320; // preferred anchored width
                const minWidth = 200;

                // compute available space to the right of the button (viewport coords)
                const availableRight = window.innerWidth - rect.right - gap - 20;
                let widthToUse = desiredWidth;
                if (availableRight < desiredWidth) {
                    if (availableRight >= minWidth) widthToUse = availableRight;
                    else widthToUse = Math.max(minWidth, Math.min(desiredWidth, window.innerWidth - 40));
                }

                // left/top in viewport coords (use rect values since anchored is fixed)
                let leftPos = rect.right + gap;
                // Align panel top with button top
                const topPos = rect.top;

                // clamp left so panel remains visible
                if (leftPos + widthToUse > window.innerWidth - 10) {
                    leftPos = Math.max(10, window.innerWidth - widthToUse - 10);
                }

                contactPanel.classList.add('anchored');
                contactPanel.style.position = 'fixed';
                contactPanel.style.width = widthToUse + 'px';
                contactPanel.style.left = leftPos + 'px';
                contactPanel.style.top = topPos + 'px';
                contactPanel.style.right = '';

                contactPanel.classList.add('open');
                contactPanel.setAttribute('aria-hidden', 'false');
                // show overlay and prevent page scroll
                if (overlay) { overlay.classList.add('visible'); overlay.setAttribute('aria-hidden','false'); }

                // set positive shift; CSS applies negative transform to move content left
                const shift = widthToUse + gap;
                document.documentElement.style.setProperty('--contact-shift', shift + 'px');
                // Adjust panel position to move left with the page shift and keep it next to button
                contactPanel.style.left = (leftPos - shift) + 'px';
                document.body.classList.add('shifted');
                document.body.style.overflow = 'hidden';
                // Prevent immediate document click from closing the panel
                window.__contactJustOpened = true;
                setTimeout(() => { window.__contactJustOpened = false; }, 300);
            }

            function closePanel() {
                if (!contactPanel) return;
                contactPanel.classList.remove('open', 'anchored');
                contactPanel.setAttribute('aria-hidden', 'true');
                contactPanel.style.left = '';
                contactPanel.style.top = '';
                // hide overlay and restore scrolling
                if (overlay) { overlay.classList.remove('visible'); overlay.setAttribute('aria-hidden','true'); }
                document.body.classList.remove('shifted');
                document.body.style.overflow = '';
                document.documentElement.style.removeProperty('--contact-shift');
            }

            if (contactBtn) {
                contactBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (contactPanel.classList.contains('open')) closePanel();
                    else openPanel();
                });
            }

            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    closePanel();
                });
            }

            // Close on Escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closePanel();
            });

            // Click outside to close (safe checks)
            document.addEventListener('click', (e) => {
                if (!contactPanel) return;
                if (!contactPanel.classList.contains('open')) return;
                // ignore the first document click right after opening
                if (window.__contactJustOpened) return;
                // clicks inside the panel should not close it
                if (contactPanel.contains(e.target)) return;
                // safe check for closest (some targets may be text nodes)
                try {
                    if (e.target && e.target.closest && e.target.closest('#contact-btn')) return;
                } catch (err) {
                    // ignore and proceed to close
                }
                closePanel();
            });

            // overlay click closes
            if (overlay) {
                overlay.addEventListener('click', (e) => {
                    e.stopPropagation();
                    closePanel();
                });
            }

            // Prevent clicks inside the panel from bubbling to document
            if (contactPanel) {
                contactPanel.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
            
            // Store closePanel in window for use by email form
            window.__closeContactPanel = closePanel;
        })();
    </script>

</body>
</html>
